---
title: "Data processing"
output: html_notebook
---

Ctrl + Shift + Enter - run cell.
Ctrl + Alt + I - insert new cell.
Ctrl + Shift + K - preview HTML result document.

# Packages
```{r}
library(leaps)
```


# Download data

```{r}
file_path = './Data/OnlineNewsPopularity_processed.csv'
data = read.csv(file_path)
print(dim(data))
head(data)
```

```{r}
data = data[, -1] # removing url column
head(data)
stopifnot(dim(data)[2] == 60)
```


# Subsetting training data

```{r}
train_percent = 0.1

sample <- sample.int(
  n = nrow(data), 
  size = floor(train_percent*nrow(data)), 
  replace = F
)

train <- data[sample, ]
test  <- data[-sample, ]

cat('Train size', dim(train), '\n')
cat('Test size', dim(test), '\n')
```
```{r}
Y_colname = colnames(data)[length(colnames(data))]
stopifnot(Y_colname == 'shares')

X_colnames = colnames(data)[1 : length(colnames(data)) - 1]

# X = as.matrix(data[, X_colnames])
# Y = data[, Y_colname]

stopifnot(length(Y_colname) + length(X_colnames) == dim(data)[2])
stopifnot(dim(train)[2] - 1 == dim(train[, X_colnames])[2])
```


# Full linear model

```{r}
full_model = lm(train[,Y_colname] ~ ., data = train[, X_colnames])
```


## Model summary
```{r}
summary(full_model)
```

```{r}
par(mfrow = c(2, 2))
plot(full_model)
par(mfrow = c(1, 1))
```

```{r}
qqnorm(rstandard(full_model))
qqline(rstandard(full_model))
```

### Model residuals plot

```{r}
colnames(train)
```
```{r}
plot_residuals <- function(model){
  plot(
    fitted(model),
    residuals(model),
    col = 'gray40',
    xlab = 'fitted values',
    ylab = 'residuals'
  )
  
  lines(
    loess.smooth(fitted(model), residuals(model)),
    col = "blue",
    lwd = 2
  )
  abline(h = 0, lty = 3)
}

par(mfrow = c(1, 2))
plot(train$timedelta, train$shares)
abline(full_model, col = "blue", lwd = 2)
plot_residuals(full_model)
par(mfrow = c(1, 1))
```

```{r}
plot_residuals(full_model)
```


```{r}
plot(data$shares, data$n_tokens_content, pch = 5)
abline(full_model)
```




```{r}
# To look at coefficients
# coefficients(full_model)

# Confidence intervals for coefficients
# confint(full_model)

# Residuals
# e = residuals(full_model)

# summary(model)
# anova(full_model, reduced_model)  # Script #2 - F-test for comparison of models

# Update model
# red.mod <- update(full.mod, ~.-weight)
# summary(red.mod)
```

```{r}
e <- residuals(full_model)
RSS <- sum(e^2)
RSS
```

```{r}
plot(train$n_tokens_content, residuals(train))
plot(train$average_token_length, residuals(train))
```







# Full linear model (Y log transform) -- Poisson GLM

```{r}
full_model_log = lm(log(train[,Y_colname]) ~ ., data = train[, X_colnames])
```

## Model summary

```{r}
qqnorm(rstandard(full_model_log))
qqline(rstandard(full_model_log))
```


```{r}
summary(full_model_log)
```


```{r}
par(mfrow = c(2, 2))
plot(full_model_log)
par(mfrow = c(1, 1))
```

```{r}
plot_residuals(full_model_log)
```



# Linear model (forward / backward model selection)

Notice! That here we have two highly correlated features : 'weekday_is_friday' and 'weekday_is_saturday'


```{r}
correlated_indices = c(
  match('weekday_is_friday', names(train)),
  match('weekday_is_saturday', names(train))
)
# match
stopifnot(sum(is.na(correlated_indices)) == 0)


nvmax = 20

forward_subsets = regsubsets(
  shares ~ .,
  data = train[, -correlated_indices], 
  method = 'forward',
  nvmax = nvmax
)

backward_subsets = regsubsets(
  shares ~ .,
  data = train[, -correlated_indices], 
  method = 'backward',
  nvmax = 20
)
```

## Model summary

```{r}
plot_max_point <- function(values){
  max_idx = which.max(values)
  points(max_idx, values[max_idx], col = 'red', cex = 2, pch = 20)
}

plot_min_point <- function(values){
  min_idx = which.min(values)
  points(min_idx, values[min_idx], col = 'red', cex = 2, pch = 20)
}

plot_subsets_summary <- function(subsets_model){
  subset_summary = summary(subsets_model)
  
  xlabel = 'Number of iterations'
  linetype = 'l'
  
  par(mfrow = c(2, 2))
  
  plot(subset_summary$rss, xlab = xlabel, ylab = 'RSS', type = linetype)
  plot_min_point(values = subset_summary$rss)
  
  plot(subset_summary$adjr2, xlab = xlabel, ylab = 'Adjusted R2', type = linetype)
  plot_max_point(values = subset_summary$adjr2)
  
  plot(subset_summary$cp, xlab = xlabel, ylab = 'Cp', type = linetype)
  plot_min_point(values = subset_summary$cp)
  
  plot(subset_summary$bic, xlab = xlabel, ylab = 'BIC', type = 'l')
  plot_min_point(values = subset_summary$bic)
  
  
  # max_idx = which.max(subset_summary$adjr2)
  # points(max_idx, reg.summary$adjr2[max_idx], col="red",cex=2,pch=20)
  
  par(mfrow = c(1, 1))
}
```

## Model summary

```{r}
plot_subsets_summary(forward_subsets)
```

```{r}
plot_subsets_summary(backward_subsets)
```
```{r}
s = summary(backward_subsets)
# s$outmat
```

