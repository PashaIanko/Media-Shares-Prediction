---
title: "Data processing"
output: html_notebook
---

Ctrl + Shift + Enter - run cell.
Ctrl + Alt + I - insert new cell.
Ctrl + Shift + K - preview HTML result document.

# Download data

```{r}
file_path = './Data/OnlineNewsPopularity.csv'
save_path = './Data/OnlineNewsPopularity_processed.csv'
data = read.csv(file_path)
# attach data
```


```{r}
head(data)
```

# Data exploration
```{r}
# Shape
print('Data frame shape:')
dim(data)
```
## Data types
```{r}
print('Unique data types:')
print(unique(sapply(data, class)))

# For detailed despcription use:
# str(data)
# colnames(data)
```

```{r}
library(purrr)

# [TODO] Serious bug with picking character feature (url). It cannot pick it

num_cols = purrr::map_lgl(data, is.numeric)
num_cols = names(num_cols[num_cols == TRUE])
head(data[, num_cols])


stopifnot(dim(data[, num_cols]) == c(39644, 60))
```

## NAN, Infinity Check
```{r}
get_nan_cols <- function(df) {
  # Check NA and NAN values
  
  cols = colnames(df)
  res = c()
  for (i in cols){
    contains_nan = length(df$i[is.nan(df$i)])
    
    if (contains_nan == TRUE){
      res = append(res, i)
    }
  }
  return(res)
}

nan_cols = get_nan_cols(
  data
)
stopifnot(length(nan_cols) == 0)
```





```{r}
get_inf_cols <- function(df){
  res = c()
  cols = colnames(df)
  
  for (i in cols){
    contains_inf = TRUE %in% is.infinite(df$i)
    if (contains_inf == TRUE){
      res = append(res, col)
    }
  }
  return(res)
}

inf_cols = get_inf_cols(data)
stopifnot(length(inf_cols) == 0)
```

## Feature Engineering (??)

## Skewness & Distribution Check

```{r}
plot_hists <- function(data, features, n_cols){
  
  n_features = length(features)
  n_rows = as.integer(n_features / n_cols)
  # n_cols = as.integer(n_features / n_rows)

  while(n_cols * n_rows < n_features){
    n_rows = n_rows + 1
  }

  # Check if enough grid space for all plots
  stopifnot(as.integer(n_cols * n_rows) >= n_features)  
  par(mfrow = c(as.integer(n_rows), as.integer(n_cols)))

  par(mfrow = c(as.integer(n_rows), as.integer(n_cols)))
  for (colname in features){
    if(!is.na(colname)){
      hist(data[, colname], main = colname)
    }
  }
  
  par(mfrow = c(1, 1))
}
```



```{r}
plot_all_hists <- function(data, cols){
  index_from = 1
  portion_len = 6
  
  
  to_plot = TRUE
  while(to_plot){
    
    index_to = min(index_from + portion_len - 1, length(num_cols))
    if(index_to == length(num_cols)){
      to_plot = FALSE
    }
    
    plot_hists(
      data,
      features = cols[index_from : index_to],
      n_cols = 3
    )
    
    index_from = index_from + portion_len
  
  }
}

plot_all_hists(data, num_cols)

```

```{r}
check_skewness <- function(data, columns, skew_thresh, verbose = F){
  library(moments)
  res = c()
  for(column in columns){
    
    sk = skewness(data[, column])

    if (!(is.nan(sk)) && abs(sk) >= skew_thresh){
      
      if(verbose == T){
       cat('Column', column, 'skew =', sk, '\n')
      }
      res = append(res, column)
    }
  }
  return(res)
}


# skewness(data$max_negative_polarity)
skewed_cols = check_skewness(
  data, 
  num_cols,
  skew_thresh = 3,
  verbose = F
)
print(length(skewed_cols))
cat('skewed cols:', skewed_cols, '\n')
```



## Fixing skewness

```{r}
length(skewed_cols)
```


```{r}
plot_all_hists(data, skewed_cols)
```





```{r}
skewness_rootfix <- function(data, columns){
  library(moments)
  
  for(column in columns){
    # print(column)
    is_na_before = sum(is.na(data[, column]))
    data[, column] = (data[, column])^(1 / 3)
    is_na_after = sum(is.na(data[, column]))
    
    if(is_na_before == 0 && is_na_after > 0){
      cat('Problems with nans in column', column, '\n')
    }
  }
  return(data)
}


data = skewness_rootfix(
  data, 
  skewed_cols[
    -c(
      which(skewed_cols == 'kw_min_min'),
      which(skewed_cols == 'kw_avg_min'),
      which(skewed_cols == 'max_negative_polarity')
    )
  ]
)
```

```{r}
plot_all_hists(data, skewed_cols)
stopifnot(sum(is.na(data)) == 0)
```


## IQR analysis
```{r}
calc_outliers_percent <- function(data, col, q_low, q_high){
  col_data = data[, col]
  
  Q1 = quantile(col_data, q_low, names = FALSE)
  Q2 = quantile(col_data, q_high, names = FALSE)
  IQR = Q2 - Q1
  
  #cat('calc', Q1, Q2, IQR, '\n')
  
  no_outliers <- subset(
      data, (data[, col] > (Q1 - 1.5*IQR)) & (data[, col] < (Q2 + 1.5*IQR))
  )
  #cat('calc', dim(no_outliers), '\n')
    
  outliers_percent = (dim(data)[1] - dim(no_outliers)[1]) / dim(data)[1]
  #cat('calc', outliers_percent, '\n')
  
  return (list('Q1' = Q1, 'Q2' = Q2, 'IQR' = Q2 - Q1, 'percent' = outliers_percent))
  
}

iqr_statistics <- function(data, columns, q_low, q_high, threshold_perc, verbose){
  
  # return columns with > perc_thresh percent of outliers
  
  outlier_cols = c()
  
  for(col in columns){
    # print(col)
    col_data = data[, col]
    
    
    res = calc_outliers_percent(data, col, q_low, q_high)
    Q1 = res$Q1
    Q2 = res$Q2
    IQR = res$IQR
    
    no_outliers <- subset(
      data, (data[, col] > (Q1 - 1.5*IQR)) & (data[, col] < (Q2 + 1.5*IQR))
    )
    # print(dim(no_outliers))
    # outliers_percent = (dim(data)[1] - dim(no_outliers)[1]) / dim(data)[1]
    
    outliers_percent = res$percent
    
    if (outliers_percent > threshold_perc){
      if(verbose == T){
        cat('Column', col, ': % of outliers:', outliers_percent, '\n')
      }
      
      outlier_cols = append(outlier_cols, col)
    }
    
    
    
  }
  return(outlier_cols)
}


outlier_cols = iqr_statistics(
  data, 
  num_cols,
  q_low = 0.25,
  q_high = 0.75,
  threshold_perc = 0.1,
  verbose = T
)
```

```{r}
outlier_cols
```

```{r}
plot_all_hists(data, outlier_cols)
```

Based on that, we choose some columns to perform IQR filtering. Here, we also 
see a lot of features with 'two-populations' distribution
```{r}
columns_to_iqr_clean = c(
  'num_self_hrefs',
  'num_imgs',
  'kw_max_min',
  'self_reference_min_shares'
)

plot_all_hists(data, columns_to_iqr_clean)
```





```{r}
iqr_clean <- function(data, columns, q_low, q_high){
  
  # First, we need to collect the data on q1 and q3 values
  colnames = c()
  q1s = c()
  q3s = c()
  percents = c()
  
  for (i in 1:length(columns)){
    colname = columns[i]
    col_data = data[, colname]
    res = calc_outliers_percent(data, colname, q_low, q_high)
    
    colnames = append(colnames, colname)
    q1s = append(q1s, res$Q1)
    q3s = append(q3s, res$Q2)
    percents = append(percents, res$percent)
  }

  for (i in 1:length(colnames)){
    colname = colnames[i]
    q1 = q1s[i]
    q3 = q3s[i]
    outliers_percent = percents[i]
    print(q1, q3)
    iqr = q3 - q1

    cat('Col:', colname, 'Outliers %', outliers_percent, '\n')

    col_data = data[, colname]
    data = subset(
        data,
        (col_data > (q1 - 1.5 * iqr)) & (col_data < (q3 + 1.5 * iqr))
    )
    cat('New data size:', dim(data), '\n')
  }
  return(data)
  
}


data = iqr_clean(
  data, 
  columns = columns_to_iqr_clean,
  q_low = 0.25,
  q_high = 0.75
)
```

```{r}
plot_all_hists(data, columns_to_iqr_clean)
```

# Saving data

```{r}
write.csv(data, save_path)
```












